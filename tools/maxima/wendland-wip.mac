/* returns a wendland polynom */
load("pw.mac");
load("romberg");

laguerre(g, k):= buildq([body: fullratsimp(exp(r)*r^(-g)/k!*diff(exp(-r)*r^(k+g), r, k))], lambda([r], body));

wendland(ndim, k):= block([w, r],
  local(plusfun, I, p),
  plusfun(x):= x*(signum(x)+1)/2,
  I(phi):= ''(pwint(t*phi(t), t, 'r, +inf)),
  p[l]:= if l=0 then 1 else buildq([g: plusfun(1-'r)^l], lambda([r], g)),
  I[k, f]:= if k=0 then f elseif k=1 then buildq([g: pwint(t*f(t), t, 'r, 1)], lambda([r], g))
  else I[k-1, I[1, f]],
  w: I[k, p[floor(ndim/2)+k+1]],
  buildq([g: fullratsimp(pwsimp(fullratsimp(w(abs('r))), 'r))], lambda([r], g))
  );

/* takes a kernel function and returns a normalized version of it */
normkern(w, ndim, [cutoff]):= block([wr, A, r],
  cutoff: if emptyp(cutoff) then +inf else first(cutoff),
  wr: buildq([g: if ndim=1 then 2*w('r) else if ndim=2 then 2*%pi*w('r)*'r else if ndim=3 then 4*%pi*w('r)*r^2], lambda([r], g)),
  A: fullratsimp(1/pwint( wr(r), r, 0, cutoff)),
  buildq([g: A*w('r)], lambda([r], g)));

/* returns Nth moment of the kernel */
getkernmom(w, ndim, N, [cutoff]):= block([wr, r],
  cutoff: if emptyp(cutoff) then +inf else first(cutoff),
  wr: buildq([g: if ndim=1 then 2*w(r) else if ndim=2 then 2*%pi*w(r)*r else if ndim=3 then 4*%pi*w(r)*r^2], lambda([r], g)),
  fullratsimp(pwint(r^N*wr(r), r, 0, cutoff)));

plusfun(x)::= (signum(x) + 1)/2 * x;

/*
Define b-spline function with explicit formula and via convolution
http://sepwww.stanford.edu/public/docs/sep105/sergey2/paper_html/node5.html
http://crsouza.blogspot.de/2010/03/kernel-functions-for-machine-learning.html#bspline
*/
bspline(n):= block([x, r],
  buildq([
    g: fullratsimp(pwsimp(1/n!*sum(binomial(n+1,k)*(-1)^k*plusfun((n+1)/2*x+(n+1)/2-k)^n, k, 0, n+1), x))],
    lambda([x], g)));

bspline_c(k):= block([w, n, r],
  local(unitbox, I),
  unitbox(x):= (signum(x+1/2)-signum(x-1/2))/2,
  I[n]:= if n=0 then lambda([x], unitbox(x)) else block([f: I[n-1]],
    buildq([g: pwsimp(pwint(f(t)*unitbox(x-t), t, -inf, +inf), x)],
      lambda([x], g))),
  w: I[k],
  buildq([g: fullratsimp(pwsimp(fullratsimp(w((k+1)/2*r)), r))], lambda([r], g))
  );

matchdeclare(www, true);
tellsimp(bessel_j(1/2, www), sqrt(2/(%pi*www))*sin(www));
load("romberg");
Fn(w, ndim, ifun, cutoff):= subst(
  [p=block([], local(r), assume(r>0), assume(t>0), fullratsimp(w(r)*bessel_j(ndim/2-1, 2*%pi*r*t)*r^(ndim/2)/t^(ndim/2-1))),
  integrator=ifun,
  c=cutoff,
  nd=ndim],
  lambda([t],
      (2*%pi)*integrator(p, r, 1e-10, c)));
linspace(a,b,n) := makelist(a+(i-1)*(b-a)/(n-1), i,1,n);

matchdeclare(rr, true);
matchdeclare(oo, freeof(x));
defmatch(fsin, rr*sin(oo*x), x);
/* integrate function of the form f(t)*sin(omega*t) */
insin(F, x, a, b):= block([m, om, f],
  m: fsin(F, x),
  om: assoc('oo, m),
  f:  assoc('rr, m),
  quad_qawo(f, x, a, b, om, sin)[1]
  );

ndim: 2;
load("sph-kernel.mac");
/* w: normkern(wendland(ndim, 3), ndim); */
kill(wl, dwl, w);
M: 2;

ratprint: false;
keepfloat: true;
wraw: buildq([g: laguerre(ndim/2, M)(eps^2*r^2)*wendland(ndim, 2)(r)], lambda([r], g));
eq: getkernmom(wraw, ndim, 2, 1);
ro: sort(sublist(map('rhs, allroots(float(eq))), lambda([q], q>0)));

w1: buildq([g: subst(0.1, eps, wraw('r))], lambda([r], g));
w2: buildq([g: subst(3.0, eps, wraw('r))], lambda([r], g));

/* eq_ab: subst(0, r, diff(w1(r), r, 2)) + B*subst(0, r, diff(w2(r), r, 2)) = 0; */
eq_ab: getkernmom(lambda([r], w1('r)+B*w2('r)), ndim, 2);
Bin: rhs(float(solve(eq_ab, B)[1]));
wbn: buildq([g: fullratsimp(w1('r) + Bin*w2('r))], lambda([r], g));


w: normkern(wbn, ndim, 1);
w1: normkern(w1, ndim, 1);

f: Fn(w, ndim, romberg, 1);
f1: Fn(w1, ndim, romberg, 1);

sig2: 1/ndim*getkernmom(w, ndim, 2, 1);
h: max(abs(2*sqrt(sig2)), 1/2);

/*
kill(wb);
wb[n](k):= 3*(n/k)^(n+2)*(sin(k/n))^n*(1-(k/n)*cot(k/n));
wbfl: map(lambda([q], wb[4](2*%pi*q)), tl);
*/

/*
plot2d(
  [
      [parametric, %pi*h*t, f(t)],
      [parametric, %pi*h*t, f1(t)]
  ],
  ['nticks, 500],
  ['t, 1e-5, 6], 
  ['logy], ['y, 1e-6, 1.1], ['x, 0, 3*%pi]);
*/

load("dump2maxima.mac");
finput: "~/work/lammps-sdpd/examples/USER/sdpd/diff/c1.44e+02-ndim2-eta8.0-sdpd_background0.0-nx30-n5.00e+00-ktypelaguerrewendland4/dump00040000.dat";
[lmp_data, atom_data]: dump2maxima(finput)$
Lx: lmp_data['xhi] - lmp_data['xlo]$
Ly: lmp_data['yhi] - lmp_data['ylo]$
ncut: 3.0$
cutoff: 1.2/30.0 * ncut$
/* rescale kernel */

/* w: wendland(ndim, 3)$ */
wexpr: w(abs('r/cutoff))$
wr: lambda([r], ''wexpr)$
w:  normkern(wr, ndim, cutoff)$

vabs(R):= sqrt(R.R);
dR(A, B):= block([del, dmin, d, dV],
  dmin: +inf,
  for del in map(lambda([idx], idx*[Lx, Ly]), listify(cartesian_product( {-1, 0, 1}, {-1, 0, 1}))) do (
    dV: A - (B+del),
    d: vabs(dV),
    if d<dmin then (dmin: d, dr: dV)
    ),
  dr
  );
nselect: 50;
getcell():= block([i, j, cell_lst], 
  cell_lst: makelist([], i, 1, nselect),
  for i: 1 thru nselect do (
    print(i),
     for j: 1 thru npart do block([
      rr: vabs(dR(r[i], r[j]))],
      if rr<cutoff then cell_lst[i]: cons(j, cell_lst[i])
      )
    ),
  cell_lst);

npart: lmp_data['natoms];
sdpd_mass: 1.0*(1.2/30.0)^2;
r: transpose(matrix(atom_data['x], atom_data['y]))$
cellfile: sconcat(finput, ".cell.n", ncut);
if emptyp(errcatch(load(cellfile))) then
  (cell_lst: getcell(),
    save(cellfile, cell_lst));

m: makelist(sdpd_mass, i, 1, npart)$
rho: makelist(
  block([],
    if mod(i, 100)=0 then print("calculating rho: ", i),
    m[i]*lsum(block(
        [dist: vabs(dR(r[i], r[j]))],
        w(dist)),
      j, cell_lst[i])),
    i, 1, nselect
  )$
float([apply('min, rho)/apply('max, rho)]);
